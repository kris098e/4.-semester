![[_08a_type_equivalence.pdf]]
# Structural equivalence
same structure, all fields in the type comes in the same order

# Equivalence by name
If they have the same name (the class), they are the same.
* java uses by name
* haskell uses by name

# Compatability
i.e can use floats and ints, fx. `1+2.3`

# Type conversion
Compiler can infer the type. fx. if a function expects a float, but you give an actual parameter of type int, the compiler will just use it as a float

# Cast
Type casting

# Type inference

# Polymorphism
ad hoc polymorphism: overloeading

Parametric polymorphism

generics

implicit parametric

subtype polymorphism

# Type-safe languages
languages where explicit deallocation cannot be type-safe

why do we want type-safe languages? Because if we have a type-safe language and it can be compiled, then it can be run. This may not be the case of non-type-safe.

