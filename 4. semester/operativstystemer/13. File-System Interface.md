A file system i s a directory with all metadata and then a large data section with files.

`/proc` all processes currently running  with info

different kind of file-systems

`sshfs` mounting a remote directory into some destination directory

FUSE (Filesystem user mode)

`./lfs test` will mount the implemented file system into the directory `test`

`./lfs -f test` will print out all the printf's-statements when using the filesystem.


linking via `ln` command. deep linking, and soft linking. Deep-> same file/dir. soft -> not same file/dir
Hard links not allowed for directories



# File Concepts
Has size of 16 bytes but are allocated 8 blocks each of 512 bytes each. Also all of the files on the file system has Inodes.
![[Pasted image 20230611073640.png]]
A file is a contigous logical address space, i.e done fx via paging reading 1 end to the next

## File attributes
[[ch13.pdf#page=5]]
use extensions like `.png` but it is the magic number which actually tells what the file is. Can be seen in some location of the bytes of the file, which defines the file type. 
The `file` command will look at the magic number stored, changing the extension may not actually change this.

## File operations
such as create,delete,read, write, open, close, change the ownership

## Open file table
with file-open table count which is used to see if fx 0 processes has this file opened, then remove.

## Open file Locking
different types of locks, fx only want one process to have this file open. Similair to having reader-writer locks or exclusive locks. Can open some part of a file with some lock and the other with another lock.

## File Structure
sequential access
random access
index file (fx having a database, store a `key : index` set, which indexes into a database file)

## Directory structure
Shallow in this structure, see the next chapters 

## Disk structure
divided into two methodologies:
partition: just some arbitary length of blocks in disk
volumes: a partition with a file system
![[Pasted image 20230611080507.png]]
The **directory** is not an actual directory as we know it, but it is the directory for the file system, storing all meta information about all the files and other information the operating system needs.

# Types of file systems
Reasons why we may want to mount different partitions onto our harddisk is to seperate the different storage, fx mount the operating system, mount the directories, mount procfs - keeping the information on different mountings. This way if the physical computer is crashing, the mounts are still okay

Also to get different kind of information from the kernel.

This will effectively also split the job of keeping information in each of its own file systems, such that if another partition is changed but the system crashed in the midst of it, the other partitions are not effected by it
## Procfs
Can mount different file systems on the filesystem, mounting on a specific path giving access to the files stored on the mounted file system. Fx `procfs` is mounted on `/proc` which gives users an insight into how the system is seen by the kernel
## tmpfs
Lives in main memory, therefore removed once turned off

# Operations on OS directory
Traverse file system, find file, delete file, rename file ...
fx `find`, `ls` 

# Directory organization
read slides [[ch13.pdf#page=24]]

efficiency: fx keeping a copy of the file in main memory such that we dont have to go to the harddisk.

## Single level
can not have subdirectories

## Two level
directory for each user, still no subdirectories [[ch13.pdf#page=26]]

## Tree structured
What you think we have at the moment based on the visual, having subdirectories and can delete entire directories recursively

## Asyclic-Graph Directories
[[ch13.pdf#page=30]]
Like tree structured, however you can have files which points to the same content in different places, which does not have to have the same name

### ln (link)
#### Hard link
making a file in a directory, modifying it and typing `ln theFile somename` will create a link to `theFile` to `somename` and they will be seen as if they are the same file, with the same `Inode` with the **links: 2**.
![[Pasted image 20230611084732.png]]
can remove the file again, showing that **links: 1** now for the file that was not removed.

#### Soft links
on directories, we are not able to make a hard link to a directory where the directory is stored. However can make soft links with `ln -s` . Can then do this
![[Pasted image 20230611085120.png]]
![[Pasted image 20230611085221.png]]
This would create troubles, fx when using `find` it would go on forever

## General Graph Directory

## File system mounting
Fx mounting a backup which lives on a remote computer in some directory. Mounted onto this volume/filesystem

`sshfs` another filesystem implementation allowing to grab a remote directory into some directory on the local machine.
`FUSE` file system in userspace, only needs some kernel modules and can use this FUSE, allowing not to interact with the kernel code.

# File sharing
May be done across networks
**NFS** is stateless, i.e does not know anything about a pointer into files. Only satisfy requests to give some blocks and then  closing the files again.  This means it is inneficient, because it may have to do things multiple time. However, it is a strategy because networking is volatile to errors, i.e if u have a open file and the server crashed. What happens?
`nfs4` mostly used, 
`nsf3` was insecure: a list of **these machines can mount this directory**. So just fake your IP and you can mount it. Plug into ethernet of fx IMADA and could mount some directories you should not be able to.
System calls are translated into the remote server system calls to alter files.


**Multi-user system** for file sharing, see [[ch13.pdf#page=37]]

## Consistency semantics
what happens when two users modify a file at the same time
**policy**.
if one user modify a file, when does the other see it?
- UNIX: immediately
- Network: can take a bit longer
- Andrew file system: handles 1000 of users. Uses **session semantics**. Changes only visible to others after the session is closed. Copy the file to local, when closing connection, it is written back. If two users modify the same file, you get a callback saying it didnt work. 
	- Efficient, but the user has to handle what happens if not working with the write back the first time

## Access control lists and Groups for Multi-user systems
Also discussed in OS protection. 
Just think about the `chmod`, first the user, the group and then everyone else. Can use `chmod` and `chown`.