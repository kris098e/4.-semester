---------------------
# Remember
CPU talks to device driver, and the device driver then talks to the controller to do something. 

# I/O Hardware
Computer talks via ports to I/O devices, talking with their controller. This can be integrated in the computer (fx the computer has integration with disc, RAM) or via device driver from outside
Communication goes via the bus, fx PCI bus.
[[ch12.pdf#page=6]]

# Addressing the devices
[[ch12.pdf#page=8]] each device live on some I/O address range

# Polling
The CPU repeatedly polls, i.e it checks the busy bit in the device controller. When it is cleared, the CPU can write a specific command to the I/O device, the I/O device sees this and sets the busy bit to do the command. When done it clears the busy bit and the CPU can take the data that was given from the command.

If the I/O device is rarely active, you may lose some CPU cycles on actively polling each device, as if they are not ready, then you waste the time it takes to poll it.

# Interrupts / latency
The I/O device can just generate an interrupt to the CPU when it is finished with its operation, signaling data are there to be read.
There are **thousands of interrupts** per second.

# Direct memory access
**Example of why I/O devices are useful**
Dont want to use the CPU to access memory -> can use the device driver for the DMA. CPU activates the device driver, which tells controller to transfer memory into address `x`. It still uses the BUS, but still effectively and generally much faster than using the CPU for the entire system.

# Application I/O interface
Devices may vary in their behavior. [[ch12.pdf#page=17]]

# Kernel I/O Structure
![[ch12.pdf#page=18]]

# Characteristics of I/O devices
major and minor number
`ioctl()`

# Character devices
methods such as `get()` and `put()`

# Nonblocking and Asynchronous I/O
+ blocking (blocks until output is ready)
+ Nonblocking (get control back immediately, but also gets some information back, can later call `Wait()` for the data)
+ Asynchronous (get control immediately, but dont get any information back immediately, can later call `wait()` for the data)

# Kernel I/O Subsystem
**Double buffering:** Have one buffer for fx new information and a buffer which is a copy of what was previously in the buffer with the new information, doing some operations on it. So we dont lose data. Fx if having to show images, dont want to show the image before it is completely done.

**caching**: entity in faster memory
**spooling**: hold output for a device. Device is slow, need to hold the current task. 

# Power management
Device drivers keeps track of if the device is in use or not, if not -> turn it off or hibernate.

# Life cycle of an I/O request
[[ch12.pdf#page=40]]
