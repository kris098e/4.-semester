page tabels: have index | frame number. Then frame number with offset gives the correct physical address.

if hierachical page tables, out index goes to inner page table index which has the frame number.

# Logical memory address
Given to memory addressing control unit to refer to physical memory address
Page tables = mapping from logical memory address to physical

logical memory addresses are generated by the CPU

# Operating system
lives in main memory

# access
process may not access something outside of its own memory??

# Static and dynamic loading of libaries
If finding a libary online already compiled it will probably be slower, since it isnt compiled to your architecture

# contigious memory allocation
a process lives in base to $base + limit$

# dynamic storage-allocation problem
first fit
best fit 
worst fit

according to the process size

# Fragmentation
internel - the memory in the specific block that are used
external - the entire programs memory use

# Paging
logical mem = pages
physical mem = frames

all split into blocks of the same size.

core data structure for mapping pages to frames is a page-table

![[Pasted image 20230322145634.png]]
in a 32 bit architecture, if the block size is of size in (fx $2^{12}=4kB$), i.e we use 12 bits for the offset,  then we have $32-12=20$bits left for the page number.

page number is an ID into the page table 

$2^{20}$ page indexes, which is 1MB for the page table? Each process has its own page-table, so each process needs this much extra memory for the page-table.

## Translation look aside buffer TLB
look example in page

## Memory protection
each process has its own page table?

valid and invalid bits to guard access

## shared paging
dont duplicate libraries

## Page replacement
Different algorithms to use

Or can just select a victim frame and kill it


### FIFO
### LRU
### OPT (cannot be implemented
### Second-chance
### LFU
### MFU


## Thrashing
keep track of how many pages are processes **REALLY** using is used.

# Allocation of memory in kernel
Different that user-mode allocation

## Buddy system
## Slab allocator

# Important
* Page faults happens when the frame we want to access in the physical memory is not in the main memory, then we have to look at the harddisk/SSD or other

* global and local page replacement
* working-set (frames that are in use for a process)
* thrashing
	* If CPU utilization is going down while the sum of working-sets is actually equal to main memory -> start killing processes, ?as thrashing still may be happening?
* 
	