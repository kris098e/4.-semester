Bankers algorithm is a Deadlock avoidance algorithm 
![[ch08-2023.pdf]]


The OS has not any known deadlock prevention implementation, therefore it is solely up to the programmer.
# processes uses resources
CPU, memory, locks.

Locks are typicly associated with the object for which is should be guarding.
Process may not request more resources than what is available.
Process must request a resource before using it and release after

If a thread requests for a resource, the system keeps check of which thread(s) holds the resources. If it is not there, the call to `acquire()` blocks the thread and will put it in the queue for that resource.

The system is deadlocked if every thread in the set is waiting for an event that be caused only by another thread in the set.

# Livelock
Livelock is different from deadlocks, as this means fx two threads try get the other thread's mutex (i.e does not call to get it, but tries it), then the threads are not blocked, but they will just try again. If this happens the threads are not deadlocked, because they are not locked, they will just keep calling the try. Prevented in networking fx by introducing random backoff timers, releasing the lock each time they fail the try. But if they try again at the same time, then same situation will just happen again.

# Four conditions
that **has to be met** for a deadlock to occur

some of the characterizations implies the other. fx. circular wait implies hold and wait

1. Mutual exclusion. if a thread wants a resource the other thread is holding, then it must wait
2. Hold and Wait. Thread must hold one resource and wait for a resource another thread is holding.
3. No preemption. A resource can only voluntarily be released by a process
4. Circular wait. threads must depend on each others resources in a circular fashion


# Resource-allocation graph
processes and resources
cycle can mean a deadlock. There is examples where a cycle doesnt mean a deadlock
If only one resource per resource-type, a cycle means deadlock

# Methods for handling deadlocks
• We can ignore the problem altogether and pretend that deadlocks never
occur in the system.
• We can use a protocol to prevent or avoid deadlocks, ensuring that the
system will never enter a deadlocked state.
• We can allow the system to enter a deadlocked state, detect it, and recover.

The OS goes with the approach of acting like they are not there - meaning the developers will have to ensure that no deadlocks occur, using protocols

Each process must tell which resources it will try acquire doing its lifetime, such that the OS can take decisions on allowing the process to run or not.

If no measures are taken, some processes will hug some resources for the entirety of the running OS before restarting, resulting system slowdowns

Sometimes the methods taken into use are not worth the overhead, and since deadlocks may occur rarely, sometimes it is just not worth the overhead. Also the state **can be recoverable**.
# Deadlock prevention
**Limits how requests can be made**
ensure all 4 conditions are not met

+ Mutual Excelusion (make sure one resource is always available, fx read-only files needs no mutual exclusion. However as fx mutex lock are nonsharable, it  will be hard to implement this one)
+ Hold and Wait 
could require a thread to acquire all of its resources that it will need before beginning execution. However this is not natural, since the code will not need all of the resources when doing something which does not require it
Could also say that a thread may one request one resource, and before requesting more, they must release the resource it holds.

both have disadvantages, and suffer from poor performance

* No preemption
Could start preempting resources from a process if it requests a resource which it cannot get access to immediatly, it is blocked, all of its resources are taken away from it, , and added to the list of resources it needs.

Can also look to see if another process has the resources it needs, if found a process, preempt its resources and start. 

* Circular wait
Here comes a very practical condition to impose on the ordering of lock-acquiring. We require that the processes must acquire the locks in some total ordering, i.e you have to acquire locks in an ascending ordering.


# Deadlock avoidance
Meaning that the system always has to be in a safe state.

Needs a priori information, based on the `maximum number` of resources the thread will need. Based on this knowledge we can know if we should actually allow the request or deny it.
Safe states and unsafe states, can be analyzed via bankers algorithm

When a thread terminates it releases all of its resources. When T i terminates, T i+1 can obtain its needed resources, and so on. If no such sequence exists, then the system state is said to be unsafe. 
**safe state** is not a deadlocked state
**unsafe state** means that the system can be deadlocked, but necessarily.

Examples looks like this:
![[Pasted image 20230602191416.png]]

## Resource-Allocation-Graph-Algorithm
If only having one resource per resource-type when we can simply use a variation of the resource-allocaltion-graph. Introducing a `claim-edge` indicating a thread may request the resource

When a thread makes a request for resources, the claim edges are turned into request edges. If this result in a cycle, then the request cannot be accepted.


## Bankers algorithm
**Look at the amount of available resources and compare them with the need matrix. And try to see if you can satisfy one need, update available, satisfy the next need ... until all requests are satisfied**
IMPORTANT TO LOOK AT THE NEEDS it makes it a lot easier.

Again when a new thread enters the system it must tell how many resources it will maximally need. When a thread requests resources, bankers algorithm will be ran. If the resulting state is a safe state we grant it the resources, else we dont.

see the explanation in slides
### data structures
#### max
what is the worst case for how many resources this process will want to get.
#### allocation
what is currently being allocated 
#### Available
how many resources are currently available.
#### Need
what the process may need more before meeting the max scenario. Is $max-all ocation$

**safety algorithm** check for each `need-entry` whether there is one that is lower than `Available`. If there is such a thing, simulate that you have reclaimed the resources, and check again for the others. Else if no such entry exists, go to failure - cannot allow the request.

When making a request, 
check
1. request <= need (check that the thread does not try to get more resources than what it started saying it would)
2. request <= available
3. check if state is safe if both passes
pretend resources are allocated, and see if state is safe

Available = Available–Request i
Allocation i = Allocation i + Request i
Need i = Need i –Request i

If not safe, restore previous state and dont grant the resources.

# Deadlock Detection
If allowing a deadlock to occur, should have algorithm to **detect deadlocks**. Also to **recover** from deadlocks

## Single Instance of Each Resource Type
System keep a state in a form of a resource-allocation-graph. This is collapsed into a `wait-for` graph, collapsing the graph such that there are no resource nodes anymore 
![[Pasted image 20230603072022.png]]
Can then invoke a detection of cycles periodically on graph, checking if there are cycles 

Can use the **BCC-tool**:
When request is made, mimic the request, run cycle detection `O(n^2)`. 
There is a tool, `BCC` which can detect deadlocks based on the calls to `pthread_mutex_lock()` and `pthread_mutex_unlock()`, tracing the calls to these, each call the tool will make graph, reporting if there are any cycles. 
However this tool is not applicable to systems with more instances to resources than 1.

## Several Instances of a Resource Type
variant of bankers algorithm, simply adding that if a thread cannot finish, then the system is deadlocked, and the ones that didnt finish, are deadlocked.

Request `O(m*n^2)`

## Detection-Algorithm Usage
1. How often is a deadlock likely to occur?
2. How many threads will be affected by deadlock when it happens?
If deadlocks occur frequently, then the detection algorithm should be invoked
frequently. Resources allocated to deadlocked threads will be idle until the
deadlock can be broken. In addition, the number of threads involved in the
deadlock cycle may grow.

Can also define that if CPU-utilization drops below some threshold, then invoke. Or at some time-intervals



# Recovery from deadlock
Two posibilities:
* kill a process such that resources are released
* preempt resources

## Process and Thread Termination
+ kill all processes in the deadlock: lose data which the threads may have used long time on
+ kill one process at a time in the deadlock: overhead from running the **deadlock-detection algorithm** every time a process is killed.

killing a process in the midst of updating a file or some data structure, will leave the state in a random state. Meaning we have to revert the changes, which may be hard

upon killing one process, which should it be? Think about
1. What the priority of the process is
2. How long the process has computed and how much longer the process
will compute before completing its designated task
3. How many and what types of resources the process has used (for exam-
ple, whether the resources are simple to preempt)
4. How many more resources the process needs in order to complete
5. How many processes will need to be terminated


## Resource Preemption
+ selecting a victim
	+ how many resources the thread has, and how long the process has been running for
+ starvation
	+ how long before the process gets its resources back
	+ need to keep state of how many times this task has been preempted, ensuring bounded waiting