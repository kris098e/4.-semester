![[ch02.pdf]]


# services provided by the operating system
## User interface
* GUI
* Touch-screen interface
* command-line interface
Some systems provide all of the above, some does not.


### CLI
the code interpreter may itself be containing all the code. I.e if a command is called, it may need to jump to some specific code in its own address space, and execute the code there.
Another approach is to store the different system programs somewhere, and when a command is called, it just loads and runs the system program to be executed. This is used in UNIX.

Used mostly because of speed once you get to know the commands, and because you can make bash-scripts

### GUI
The mouse is used to select programs for the operating system to be run. This is implemented in most of the modern operating systems, with a few exceptions such as arch-linux which only has CLI

More user friendly

### Touch-screen interface
User friendly, used mostly in smart phones


## Program execution
be able to load a program into main memory and run it. The execution should be able to end normally or abnormally

## I/O operations
Interact with the hardware

## File-system manipulation
Be able to make, change, delete files and directories, permissions

## Communication
between processes for efficiency reasons, shared memory or message passing

## Error detection
Both in hardware devices where it may need to halt the system, or if a process fails it may just return error to the caller 

## Resource allocation
Main memory, CPU-schedualing

## Logging
For debugging

## Protection and security
fx password protected before you can access some part of the memory or some I/O devices


## System-calls
written in C, C++ or assembly, but there are coming some RUST-programs into the kernel aswel
Assembly is used when hardware needs to be accessed directly
The `cp` command uses many system calls. Accept input for the files to read and write to, open them, read and write, close files, output to terminal, terminate normally or with errors.

### application programming interfaces API
Windows API and POSIX API (Unix, Linux, MacOS), java API. Programmer accesses the API via libraries.
The library functions then themselves uses the System calls.

Use because it is more portable, the programs can run on any machine that supports the same API
Often easier to use the interface as the underlying function may use many different systemcalls. 

### Types of system calls
• Process control
	◦ create process, terminate process
	◦ load, execute
	◦ get process attributes, set process attributes
	◦ wait event, signal event (locking)
	◦ allocate and free memory
• File management
	◦ create file, delete file
	◦ open, close
	◦ read, write, reposition
	◦ get file attributes, set file attributes
• Device management (I/O devices, way to speak to hardware, can be be loaded when needed)
	◦ request device, release device
	◦ read, write, reposition (seen as if it were a file) 
	◦ get device attributes, set device attributes
	◦ logically attach or detach devices
• Information maintenance (debugging of the system and convenience with easier implementation of some mechanisms)
	◦ get time or date, set time or date
	◦ get system data, set system data
	◦ get process, file, or device attributes
	◦ set process, file, or device attributes
• Communications (shared memory, message passing)
message passing is slower, but better small data transfers as it also takes time to create this shared memory. Shared memory is faster once it has been created, but have some protection and synchronization issues.
	◦ create, delete communication connection
	◦ send, receive messages
	◦ transfer status information
	◦ attach or detach remote devices
• Protection
	◦ get file permissions
	◦ set file permission
![[Pasted image 20230525085147.png]]

# System services
Provided programs which does specific things

## File management
Programs that can do the modification, deletion, copy create... on files and directories. Fx path finders

## Status information
Some programs simply ask the system for the date,
time, amount of available memory or disk space, number of users, or
similar status information

## File modification
text editors

## programming language support
compilers, RTE, interpreters, debuggers for programming languages

## Program loading and execution
Programs that loads the programs needed 

## Communication
They allow users to send messages to one another’s screens, to browse web
pages, to send e-mail messages, to log in remotely, or to transfer files from
one machine to another.

## Background services
Daemons, fx network daemon always running and listening for network management tasks. Also programs that are loaded at boot-time for making the operating system run, fx systemD


# Linkers and loaders
Compiler generates relocatable object files, which is linked into one executable. Which can be loaded and the CPU core will run it. **realocation** is used such that when the binary file is executed the addresses it needs in main memory is allocated in memory, and if the program is loaded twice it will need to reallocate its addresses if it does not get into the same address space. Can use dynamic linked libaries, where the executable does not have the program linked, but if needed it will able to reach the libaries via paging to the correct address' where the library lives in memory - thus saving memory since it does not have to loaded twice this code which is dynamic linked.

## Formats of files
using ELF for unix, executable and linkable format. **ELF format** fx points to the programs entry point, containing the first instruction in the program


# why applications are operating-system specific
* Different system calls
	* different API's

## How to run on multiple systems
interpreted language, fx python will translate to native system calls for the system

Virtual Machine. The program may be executed on a virtual machine, fx JVM with JRE which has been developed for multiple systems

Use standard language or API, such that it can run on the operating systems using the same API

## Why some does not work on multiple systems
Operating system has binary format for application, for the header, instructions and variables. These needs to be a specific place in the files binary

CPU has specific instructions, some programs executable will not work on different CPUs fx ARM and x86-64

Different system calls

### actions taken to partly deal with the problem
UNIX has adopted the **ELF format** which is not tied to a specific hardware structure, but does not guarantee that it will run on all hardware.

#### ABI
the equivalent of API's but for files, specifying the address width, methods of passing parameters to system calls, the organization of the runtime-stack, the binary format of system libaries, size of data types... If a system support a specific ABI, it should be able to run the file if it is stored in the specification of the ABI.

# Operating-System design and implementation
## goals
for laptop, mobile, real time system ....

Should be easy to design, implement and maintain, flexible, reliable, error free and efficient.

## principles and mechanisms for designing
One important principle is the separation of policy from mechanism. Mechanisms determine how to do something; policies determine what will be done.

Implement the specific operating system with a specification from the policy on what should be done, and then the actual implementation of the policy is the mechanism. This means if we want to use a CPU-schedualing policy, we can implement the policy in different ways, providing that two operating systems has the same policies but different mechanisms, one can fx be implemented to be faster but less secure. In the end, we know what the operating system has to do, but not sure how it will do it - providing flexibility.  

## Implementation
The old operating system were written mostly in assembly and some C. Newer systems are implemented in C and C++ and some in assembly. fx android uses even higher level languages such as java. Many system calls are also implemented in C++. Reasons for implement it using higher level languages are that it is easier to understand, and when the compiler is improved it can just recompile.

even tho assembly code may be smaller in terms of size, in modern systems size is not an issue, therefore preference is higher level languages.

# Operating-System Structure
## Monolithic Structure
**Operating system is in one single binary file**
The simplest structure for organizing an operating system is no structure at all.
That is, place all of the functionality of the kernel into a single, static binary file
that runs in a single address space. This approach—known as a monolithic
structure —is a common technique for designing operating systems. 
This then lives in a single address space. All the services is then in this binary, with all the system calls.
Linux is implemented this way

Speed is faster for this structure

## Layered approach
Different layers are responsible for their own implementation of some functionality. The lowest layer is the hardware and the highest layer is user interface. Easy to extend since it just needs to implement the same functionality. It is like not having all code in main, but split into functions.

Slower since each layer has to pass the calls down and up.
The different layers can be debugged and tested by themselves
Debugging is from low to high, since we assume hardware functions correctly, if the layer above fails then it must be there the flaw is. It hides the implementation of from the above layer.

## Microkernels
Remove all nonessential parts of the kernel
![[Pasted image 20230525125400.png]]
Uses message passing.

Easy to extend since all new services are just added in user-space, and does not need to modify the kernel. Easy to port. Secure since less communication is being done in kernel mode. If a service fails the kernel still runs.

Microkernels are slow since each message has to be copied into different address spaces. The kernel may have to switch from one process to the next to excahnge the message.

## Modules
Loadable kernel modules
OS can link additional services via modules.
Like microkernel - the kernel can have the essentials and can then link the rest at runtime. Does not need message passing between services since they live the address space of the kernel when loaded into the kernel.

## Hybrid systems


# Building and Booting an Operating System
## Making the OS

## System Boot
1. A small piece of code known as the bootstrap program or boot loader
locates the kernel.
if using BIOS, loads a 2nd boot loader stored in a fixed location called the **boot block**
If using UEFI not multistage and can just boot the operating system
GRUB  is an open source bootstrapping program

Both will load the kernel into memory, can also run diagnostics

2. The kernel is loaded into memory and started.
3. The kernel initializes hardware.
Using temporary RAM file system (initramfs) location to startup initial drivers and file system 
4. The root file system is mounted.
from initramfs

Systemd is started.


**android** uses a boot loader called little kernel which will maintain the `initramfs` as the root filesystem after.

# Operating-System debugging
When the operating system failes its state of kernel memory is written to a place on the disc, which when the operating system is started up again a process is responsible for writing this to a log-file, which can be examined to look into the crash. 

This is different from a debug when a process is failing due to obvious reasons of the scaling of the two complexities.

## Performance tuning
To look into system-bottlenecks we must be able to monitor per-process or system-wide observations. We can use tracing or counters to examine the operations done.

counter count how many system calls are made and to which I/O devices, this is done via the `/proc` folder.

tracing will collect the all the steps done by a system-call invocation

