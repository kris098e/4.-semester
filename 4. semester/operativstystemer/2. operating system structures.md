![[ch02.pdf]]


# services provided by the operating system
## User interface
* GUI
* Touch-screen interface
* command-line interface
Some systems provide all of the above, some does not.


### CLI
the code interpreter may itself be containing all the code. I.e if a command is called, it may need to jump to some specific code in its own address space, and execute the code there.
Another approach is to store the different system programs somewhere, and when a command is called, it just loads and runs the system program to be executed. This is used in UNIX.

Used mostly because of speed once you get to know the commands, and because you can make bash-scripts

### GUI
The mouse is used to select programs for the operating system to be run. This is implemented in most of the modern operating systems, with a few exceptions such as arch-linux which only has CLI

More user friendly

### Touch-screen interface
User friendly, used mostly in smart phones


## Program execution
be able to load a program into main memory and run it. The execution should be able to end normally or abnormally

## I/O operations
Interact with the hardware

## File-system manipulation
Be able to make, change, delete files and directories, permissions

## Communication
between processes for efficiency reasons, shared memory or message passing

## Error detection
Both in hardware devices where it may need to halt the system, or if a process fails it may just return error to the caller 

## Resource allocation
Main memory, CPU-schedualing

## Logging
For debugging

## Protection and security
fx password protected before you can access some part of the memory or some I/O devices


## System-calls
written in C, C++ or assembly, but there are coming some RUST-programs into the kernel aswel
Assembly is used when hardware needs to be accessed directly
The `cp` command uses many system calls. Accept input for the files to read and write to, open them, read and write, close files, output to terminal, terminate normally or with errors.

### application programming interfaces API
Windows API and POSIX API (Unix, Linux, MacOS), java API. Programmer accesses the API via libaries.
The libary functions then themselves uses the System calls.

Use because it is more portable, the programs can run on any machine that supports the same API
Often easier to use the interface as the underlying function may use many different systemcalls. 

### Types of system calls
• Process control
	◦ create process, terminate process
	◦ load, execute
	◦ get process attributes, set process attributes
	◦ wait event, signal event
	◦ allocate and free memory
• File management
	◦ create file, delete file
	◦ open, close
	◦ read, write, reposition
	◦ get file attributes, set file attributes
• Device management (I/O devices, way to speak to hardware, can be be loaded when needed)
	◦ request device, release device
	◦ read, write, reposition (seen as if it were a file) 
	◦ get device attributes, set device attributes
	◦ logically attach or detach devices
• Information maintenance (debugging of the system and convenience with easier implementation of some mechanisms)
	◦ get time or date, set time or date
	◦ get system data, set system data
	◦ get process, file, or device attributes
	◦ set process, file, or device attributes
• Communications (shared memory, message passing)
message passing is slower, but better small data transfers as it also takes time to create this shared memory. Shared memory is faster once it has been created, but have some protection and synchronization issues.
	◦ create, delete communication connection
	◦ send, receive messages
	◦ transfer status information
	◦ attach or detach remote devices
• Protection
	◦ get file permissions
	◦ set file permission
![[Pasted image 20230525085147.png]]

# System services
Provided programs which does specific things

## File management
Programs that can do the modification, deletion, copy create... on files and directories. Fx path finders

## Status information
Some programs simply ask the system for the date,
time, amount of available memory or disk space, number of users, or
similar status information

## File modification
text editors

## programming language support
compilers, RTE, interpreters, debuggers for programming languages

## Program loading and execution
Programs that loads the programs needed 

## Communication
They allow users to send messages to one another’s screens, to browse web
pages, to send e-mail messages, to log in remotely, or to transfer files from
one machine to another.

## Background services
Daemons, fx network daemon always running and listening for network management tasks. Also programs that are loaded at boot-time for making the operating system run, fx systemD


# Linkers and loaders
Compiler generates relocatable object files, which is linked into one executable. Which can be loaded and the CPU core will run it. **realocation** is used such that when the binary file is executed the addresses it needs in main memory is allocated in memory, and if the program is loaded twice it will need to reallocate its addresses if it does not get into the same address space. Can use dynamic linked libaries, where the executable does not have the program linked, but if needed it will able to reach the libaries via paging to the correct address' where the library lives in memory - thus saving memory since it does not have to loaded twice this code which is dynamic linked.

## Formats of files
using LEF for unix, executable and linkable format. **ELF format** fx points to the programs entry point, containing the first instruction in the program


# why applications are operating-system specific
* Different system calls
	* different API's

## How to run on multiple systems
interpreted language, fx python will translate to native system calls for the system

Virtual Machine. The program may be executed on a virtual machine, fx JVM with JRE which has been developed for multiple systems

Use standard language or API, such that it can run on the operating systems using the same API

## Why some does not work on multiple systems
Operating system has binary format for application, for the header, instructions and variables. These needs to be a specific place in the files binary

CPU has specific instructions, some programs executable will not work on different CPUs fx ARM and x86-64

Different system calls

### actions taken to partly deal with the problem
UNIX has adopted the **ELF format** which is not tied to a specific hardware structure, but does not guarantee that it will run on all hardware.

#### ABI
the equivalent of API's but for files, specifying the address width, methods of passing parameters to system calls, the organization of the runtime-stack, the binary format of system libaries, size of data types... If a system support a specific ABI, it should be able to run the file if it is stored in the specification of the ABI.

# Operating-System design and implementation
## goals
for laptop, mobile, real time system ....

Should be easy to design, implement and maintain, flexible, reliable, error free and efficient.

## principles and mechanisms for designing
One important principle is the separation of policy from mechanism. Mechanisms determine how to do something; policies determine what will be done.

Implement the specific operating system with a specification from the policy on what should be done, and then the actual implementation of the policy is the mechanism. This means if we want to use a CPU-schedualing policy, we can implement the policy in different ways, providing that two operating systems has the same policies but different mechanisms, one can fx be implemented to be faster but less secure. In the end, we know what the operating system has to do, but not sure how it will do it - providing flexibility.  

