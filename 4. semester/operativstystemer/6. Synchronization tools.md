![[ch06-2023.pdf]]

# Keywords
* race condition
* Critical section (of a program) problem
	* peterson's solution (wiki proof is easier to understand than the book)
		* works for two processes
			* **mutual exclusion**
			* progress
			* Bounded waiting
	* Need assembly instructions that cannot be interrupted (atomic)
		* the other instructions are then build on top of theese.
* Memory barriers (set in between code such that load and stores before this code has been made when moving on from the memory_barrier().)
* `test_and_set` and `compare_and_swap`-instructions (**THEESE ARE HARDWARE ASSEMBLY INSTRUCTIONS that are done atomicly.**)
	* `compare and swap()`-instruction is used to implement fx the mutex lock, and is a strong tool to use. Its also used to implement `atomic variables`.
	* introduce locks
		* variation of compare_and_swap that introduce bounded waiting
* mutex lock
	* `acquire` and `release` atomicly
	* queue of processes that wants to access the lock
		* calls to `acquire` and `release` must be done atomicly, i.e the `compare_and_swap()` instruction can be used.
* lock may be implemented with `spinlocks()` with while loop, busy doing nothing, but does many checks each second. Wasted CPU-time
	* can use this if the expected lock is held for a short time
		* else go to sleep (but pays context switch time. i.e if CPU time > context switch, go with context switch else spin)
* semaphores (low level synchronization, if want to implement synchronization, better off using higher level languages that already has implented something with locks and atomic)
	* signal and wait. signal increases the variable by 1, wait decreases by 1. Signals something is available, and the waiting graps the task and decrease the variable. If the variable is 0, no tasks are available
		* `block()` block yourself
		* `wakeup()` other process wakes you up
	* The call to `wait()` and `signal()` must be done _atomicly_, such that race conditions do not happen. However as theese two instructions are short, it does not lower efficency of the program so much as spin locking. By using semaphores we move the busy waiting to the critical section of the application program, instead of the entry block, as we just call the semaphore and let it handle the `block()` and `wakeup()`. 
* monitors (not important to know about, just know it can be implemented with mutex locks and semaphores)
	* uses variables for which we can call `x.wait()` and `x.signal()` i.e dont have a waiting-que, but can have an array of condition variables, which if one process calls `x.wait()` then another process can free it by calling `x.signal()`. 
		* this means fx use `Condition self[5]` can then calf `self[3].wait()` and another calls `self[3].signal()`
	* Condition variables
		* `wait()` doesnt behave as `wait()` in semaphores. 
			* may produce no side effects.
		* signal and wait
		* signal and continue 
	* can be implemented with semaphores and mutex locks
* Liveness
	* are in a system state, no matter where we are in a system state, one event can always be triggered => live event
	* **quassi life** => if we can reach an event. Quassi life may not be live
	* We say that a set of processes is in a deadlocked state when every process
in the set is waiting for an event that can be caused only by another process in the
set
		* event is live if can get other events, if fx stuck in a infinite loop its not live.