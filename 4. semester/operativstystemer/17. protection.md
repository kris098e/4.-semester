In the system itself. I.e in the OS


# Protection ring
different levels of protection for the system.

## Trust zones
Some hardware may need you to be in a different trust zone to speak with it. Fx the security chip contatining the private key maybe only the cpu can talk with this.

# capability and access control lists
[[ch17-2022.pdf#page=25]]
capability the permission is stored with the domain, in the other it lives with the file

**capability more secure** page 26

# Access Matrix
[[ch17-2022.pdf#page=16]]
What different domains can invoke on objects, i.e the printer can access obbject 2 with `read`

Not implemented in real systems, theoretical

## copy rights
[[ch17-2022.pdf#page=20]]
The one with the star can give permission to the other domains

## owner  rights
if a domain own it, it can give all other domains owner rights. Change an entire row

## modified access
[[ch17-2022.pdf#page=22]]
**control** can control everything another domain should be able to do, i.e change entire row

## access control list
have an access control list to each object, i.e which can access this object.  Fx in files, which groups and users can access til file

### capability storage
save the entire row, to see which objects this user can do

# Revocation of access rights
Different methods see page 32


---
[[ch17-2022.pdf]]
Within the system

# HAVE TO BE IN EXAM
ways to store permissions. Show the domain to domain and domain to file with the operations `owner, switch, control, read, write, execute and *` and show the picture below in the access control list

# Important
the core of this chapter is access control matrixes, i.e permission checking for a user. Lives with the file. And what capability systems are (capability lives with the user)
protection rings

## Ways of storing the permissions
+ capability: with the user
+ access control list: with the file
[[ch17-2022.pdf#page=24]]
![[Pasted image 20230613141657.png]]
# Principle of protection
Dynamic and static capability. 
+ can switch or not switch domain

# Protection rings
[[ch17-2022.pdf#page=8]]
Not just user and kernel, can also be in hardware. Fx a security chip which holds the private key for the computer. 
**in the outer layer you are allowed to do more**.

Only allow programs access to some of the hardware via API's
Fx. in **ARM CPU** you have a process which monitors the system, which has the most amount of privileges

# Domain of protection
[[ch17-2022.pdf#page=13]]
Domain (user, set of access rights) is allowed to do certain operations on an object.

## Domain implementation
### UNIX
Can switch to another domain. 

+ UNIX: can use `setuid-bit` which will set the user to whichever user is set, when executing the program. Will then switch back afterwarad finish
	+ `su`: switch user
	+ `sudo`: as root

### Android
Each application gets its own user by a daemon running, such that when you want to go into an app you switch user. This means that you cannot get access to another app if you are an app without switching user.

# Access matrix
Specify what each domain/user can do on certain files or devices
[[ch17-2022.pdf#page=16]]
operations on the files [[ch17-2022.pdf#page=17]]
- Switch (a domain is allowed to switch into another domain)
	- in the **domain to domain row**
- \*  you are allowed to grant other domains the same right on the file that you have
	- fx `D1: read*` means it can give `D2: read` aswel.
- owner (a domain can control what all of the other domains may do to the file, and delete their rights)
- control 
	- in the **domain to domain row.**  Can control what the other domain can do.
		- you an control an entire row.
	
policy and mechanism [[ch17-2022.pdf#page=18]]


naive implementation is store the access matrix in main memory, however this is very large - therefore not implemented

## Access control list
to manipulate the capabilities to a file, you touch the Inode and alter the access control list

## Capability list
you cannot let the users manipulate the permissions, as they could just alter the list such that they can do all operations they want. This should only be done in kernel mode fx.
**This is harder to implement**

More secure. Fx if a file lives in main memory and you have a trojan horse. The trojan horse has to be granted the capability to manipulate a file before it can do something. Fx root may not have the capabilities of another user.

# Lock-key based access-rights
each domain has a unique bit pattern and each file has a unique lock pattern. Only if they match you can use the file


# Comparison of access rights strategies
Global cabability list is easy to implement, however it will be big and has to live in main memory for quick access. 
access control lists is sufficient for users, and easy to implement with lesser overhead.

Indexing into cabability list table will also be inefficient with many entries unless using additional algorithms and datastructures
Cabability lists localizes the capability per user instead of per file. 

difficult to implement implement groups and hierachies with locks and keys

better security with capability list, but inefficient while access control lists are easier to implement with less overhead.

## Conclusion
capability lists and access control lists are used in combination, where ACL's dominate. If you fx access a file to a get a file descriptor, when you get the file descriptor, you will have the capability of doing which operation you requested. 


# Revocation of access rights
Usually in cabability based systems, the capability list does not live in one single address space, but is spread among the many entities. Meaning it will be very hard to revocate access rights, as you **have** to find the user first. It becomes even harder when you have groups where you have to find multiple users.
ACLs it easy to remove a capability. Also for a group

different approaches to revocation[[ch17-2022.pdf#page=32]]

# Role based access control
Each role can do something specific, and you can then as a user be part of some role. Seen in Solaris
Goes for files and devices ....

# Mandatory Access Control (MAC)
DAC: user can still see objects even tho they dont have permissions to do anything with it
MAC: Objects cannot be seen by not intended users.

# System call restriction (like a firewall)
each process only gets access to the system calls they need when initially compiled. Code injection will then be harder.

# Code signing
Use crypto hash to sign that the program is trusted.

Has to be resigned every 7 days

# Programming language support
fx C you can do everything. In Java it is much harder.
In java if you want to do privileged instruction, the stack is inspected to ensure the operation can be performed by the library, again fx buffer overflow is harder to happen here.