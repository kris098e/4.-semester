Modules are dynamicly loaded kernel drivers.
These can also be staticly inserted, but better practise to dynamicly load.

when we want to use the dev, we give it a file descriptor, which private date will be sat to `dev`. We can then use the methods via this `struct file *filp`. see [[ch06_linux_modules.pdf#page=40]]

The files that belongs to a minor number are called devices. The entire structure that is shared, i.e the major number that is shared is the `driver`.

_When a process reads (consumes) from character device `/dev/dm510-0` the data is read from bounded buffer 0. If the buffer is empty the process has to wait until another process has written to `/dev/dm510-1`._
**use down_interruptible** with the condition for this, such that it will be woken when the the condition that content is ready to be read or written.

# De 2 minor number devices har 1 shared major number. Den med major number har den delte dev struct til sig. I denne skal der være 2 buffer, og så put read og writr pointer til den ene og read og write pointere til den anden. I initializering (kan også være i open), put det her med at lave pointere til bufferene for de 2 minor numbers.






To keep track of when the read and write pointers are the same, i have introduced the variable `write_wrapped` since, if we fx wrap, and the read havent read anything yet, the two pointers will both point to the head of the array. However, bytes has been written to the device, so there is actually something to read. Therefore when we wrap in the `write()` the `write_wrapped` is updated to `1` indicating the `write()` has wrapped. Everytime `read()` is called, we update the `write_wrapped()` to `0` again indicating `false`. This way, when they actually are the same, if the writing has wrapped, the read can read, since the `write()` actually has written. 

This is also used in the condition for the sleeping and the freespace, which has the same logic.
