![[ch03.pdf]]

RTC contacts a port mapper on the ip-adress, the port mapper tells back which port to contact and we contact this and the function is ran and the result is returned to the client.


A running program, i.e a loaded program and executing program is a process.

# Process Concept
processes are also refered to as `jobs` since in the early computers, processes were called exactly this.

## The Process
process in memory: 
![[Pasted image 20230526083145.png]]
The program counter tells the current state of the process 
In addition the stack, heap and data may vary if two processes are created from the same program, and they are different places in memory

## Process State
• New. The process is being created.
• Running. Instructions are being executed.
• Waiting. The process is waiting for some event to occur (such as an I/O
completion or reception of a signal).
• Ready. The process is waiting to be assigned to a processor.
• Terminated. The process has finished execution.

Only one process may be running on a core at the same time.

## Process Control Block
![[Pasted image 20230526083741.png]]
+ Cpu registers must be saved, to allow the process to be continued correctly when rescheduled to run
+ CPU -scheduling information. This information includes a process prior-
	ity, pointers to scheduling queues, and any other scheduling parameters.
+ pointers to the page tables and segment tables
+ Accounting information. Cpu real time, user time, time limits, process numbers..

## Threads
Needed such that a process can create multiple processes, such that fx a word processor can have one thread for input and another for type-checking.
When this is used, the PCB will also contain information about the threads

# Process Scheduling
The number of processes currently in memory is known as the degree of multiprogramming.

+ CPU-bound processes
+ I/O-bound processes

## Scheduling Queues
Made with linkedList where first pointer points to the first PCB in the list, and this PCB has a pointer to the next PCB in the list.

To be in queue a process either waits for a condition or is interrupted

`wait-ques` are where the waiting processes are put.
`ready-ques`

processes are `dispatched` from the ques when put on the CPU. The processes that are dispatched are chosen by the CPU-schedular

## Context Switch
When a process needs to be taken of the core it has to be `context-switched`. This means that its state is saved and the other process put in memory needs its context restored

# Operations on processes
## Process Creation
Processes creating a child process

All processes has their own process ID. Systemd has pid = 1 which spawns additional processes, such as logind and sshd

A child process can share all or only a subset of resources from the parent.

The parent may continue concurrently with the child-processes or it may wait.
The child process is a duplicate of the parent process or the child process is a new process.

## Process Termination
Done via a call to `exit()` and the exit code can be retrieved via the `wait(&status)` from the parent.

**why a parent may terminate a child**
• The child has exceeded its usage of some of the resources that it has been
allocated. (To determine whether this has occurred, the parent must have
a mechanism to inspect the state of its children.)
• The task assigned to the child is no longer required.
• The parent is exiting, and the operating system does not allow a child to
continue if its parent terminates.

If the parent does not call to `wait()` but the child has finished execution it is called a `zombie` since it cannot be popped from the process table, since it contains the processes exit status.

If the parent process has finished executing and has called `exit()` without calling `wait()` the child is an `orphan`, and its parent is assigned to either the process `init` or `systemd` which periodicly calls to `wait()` letting all orphans be released from the process table

### Android process hierachy
As the devices usually has limited memory, if a new important process needs memory, all the processes are assigned importance, and when needing memory, it just kills the least important process.

order:
1. foreground process (one used by user)
2. visible process (service process for the foreground user, the result is displayed on the foreground process)
3. service process (such as streaming music)
4. Background process (not appearent to the user)
5. Empty process (does nothing, just hugs resources)


# Interprocess communication
1. independent process: does not share data with any processes
2. cooperating, can affect or be affected by other processes

needs this because 
• Information sharing. Since several applications may be interested in the
same piece of information (for instance, copying and pasting), we must
provide an environment to allow concurrent access to such information.
• Computation speedup. If we want a particular task to run faster, we must
break it into subtasks, each of which will be executing in parallel with the
others. Notice that such a speedup can be achieved only if the computer
has multiple processing cores.
• Modularity. We may want to construct the system in a modular fashion,
dividing the system functions into separate processes or threads, as we

Shared memory is faster because it is just establishing the memory and then it is regular memory accesses afterwards. 
Message passing is implemented using system-calls requiring the need for a change to kernel-mode and also copying. 

## Shared memory
resides in the creating processes address space, others that wants to use it needs to attach it to their address space.
The processes needs to agree on being able to use this shared memory segment, as it is not usual to being able to access other process' memory

Needs synchronization

producer-consumer problem. One process produces while the other consumes, needs synchronization on this.
	bounded buffer
	unbounded buffer

## Message passing
resides in different address spaces from that of the communicating processes. May not even be on the same computer.

### Naming
Processes that wants to communicate has to specify which process it is sending and receiving from.

The problem is knowing the other processes name or identifier. The name may not be static

#### mailboxes
only have to know the name of the mailbox to communicate with all that share this mailbox

Can be owned by the operating system or by a process

But have to decide on an algorithm for who will receive which messages if two processes calls for `receive()` on it at the same time. 
Also need to decide on a policy if two processes sends at the same time, which one comes on top

### Synchronization
Blocking and nonblocking, for Send and receive.

### Buffering
The messages are stored.


# Examples of IPC Systems
## POSIX shared memory 
uses `shm_open()` for creating shared memory givng back a file descriptor
can then use `truncate(fd, size)` to specify size of the file. 
`mmap()` memory maps the file descriptor such that it is shared

The consumer can then get a file descriptor the shared memory with 
```c
fd = shm open (name, O RDONLY, 0666);
```
specifying the name and can then again get a pointer to the shared memory by using `mmap()` using the file descriptor

## Mach Message Passing
uses mailboxes 
Sends a message to one port and a reply to another reply port 

Only one process may receive from a single port, but can have multiple senders
Each process can make a port on this mailbox if it has the capability `MACH PORT RIGHT RECEIVE`, then this task can specify another process can send messages to this port by giving this process the `MACH PORT RIGHT SEND` for the given port.

Uses `mach_port_allocate()` to allocate a port
```c
mach port allocate (
mach task self(), // a task referring to itself
MACH PORT RIGHT RECEIVE, // the right for this port
&port); // the name of the port right
```

## Windows
uses port object to establish connections between two processes like Mach

Connection ports and Communication ports

A server handles the connections, via connection port. They then have communication port where they communicate

1. For small messages (up to 256 bytes), the port’s message queue is used
as intermediate storage, and the messages are copied from one process to
the other.
2. Larger messages must be passed through a section object, which is a
region of shared memory associated with the channel.
3. When the amount of data is too large to fit into a section object, an API is
available that allows server processes to read and write directly into the
address space of a client.

## Pipes
1. Does the pipe allow bidirectional communication, or is communication
unidirectional?
2. If two-way communication is allowed, is it half duplex (data can travel
only one way at a time) or full duplex (data can travel in both directions
at the same time)?
3. Must a relationship (such as parent–child) exist between the communi-
cating processes?
4. Can the pipes communicate over a network, or must the communicating
processes reside on the same machine?

### Ordinary pipes
If unidirectional two pipes must be made. Since it can only be written to in the write-end and read from in the read-end.

creation:
```c
pipe(int fd[])
```
only accessible from parent to child relationship

May close either sides of the pipes using `close()`

### Named pipes
Named `FIFOs` in the UNIX API

Can be used by multiple processes which does not require a parent-child relationsship. However the processes must reside on the same machine, else sockets are used.

# Communication in Client-Server Systems
If a process has to communicate with a process running on another machine

Uses Sockets or Remote Procedure Calls (RPCs)

## Sockets
Process listens on a specific port to accept connection. All ports below 1024 are well known ports, used by the operating system.

TCP and UDP implementation of sockets


## RPC
Remote Procedure Calls, just implies a process calls a procedure like its local to the processes address space, but the procedure is executed on another process, which is likely not on the same machine as the requesting machine.


Not just arbitary data, but a well structured communication. The server opens up an RPC-daemon. And if fx it has service that lists all the users it will bind this service to a specific port, and when contacted on this port it will invoke the specified function needed, which will return the data.

The client has `stub` which is invoked when the procedure is called, passing all the necessary information to the RPC. This uses message passing. Before `marshalling` the data to the server it is converted into `external data representation` such that no issues between storage in fx little-indian and big-indian is caused. 

The procedures should be executed only once. The server keeps a record of the timestamp of messages it has already processed, then the client can send multiple requests with the timestamp of its creating, and the server can ignore the request with the timestamps it has already processed. 

The server must ACK that it has received the RPC.

The ports are usually only changed upon compile-time of the RPC.

Used to make distributed file-system, where a call to fx `read()` is propagated to a server to a specified port, and will return

### Android RPC


