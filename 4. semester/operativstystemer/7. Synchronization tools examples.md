![[ch07-2023.pdf]]

# Keywords

* readers-writers problem
	* synchronization on some locks, and using `wait()` and `signal()` calls
		* some processes wants to write, some to read. 
			* how to synchronize?
		* same problem but with multiple readers, and a few times we have a write.
	* done with `mutex` and `semaphores`. See `page 292` in the course book
* Dining philosophers problem
	* deadlock example
		* handled via `wait()` and `signal()` calls, using **monitors** and belonging **condition variables** stored in an array for which we can signal the different condition-variables that are waited upon
* synchronization on windows
* Synchronization in linux
	* Methods for holding aqcuring locks fx `mutex_lock()` with `mutex_unlock()`
		also `preempt_disable()` with `preemt_enable()` in the kernel
	* can safely _preempt_ a kernel-process if it holds no locks, which can be seen by looking into some info the thread keeps 
* Posix
	* Mutex locks
	* semaphores
	* condition variables
	* 


# producer consumer problem
using mutexes to access the shared struct, ensuring that nothing can be posted twice to the same buffer entry and two consumers cannot get access to the same produced product


# reader writers problem
Can have multiple readers to some shared data since they dont modify, allow as many as possible into the data section, but should not read when a writer wants to write.
two solutions. 
1. if a reader wants to enter and a writer wants to enter, it does not matter which
2. if a writer wants to enter, no new readers may enter before the writer has finished writing

# Dining philosophers problem
## Semaphore
with semaphores (does not ensure bounded waiting)
```c
while (true) {
	wait(chopstick[i]);
	wait(chopstick[(i+1) % 5]);
	. . .
	/* eat for a while */
	. . .
	signal(chopstick[i]);
	signal(chopstick[(i+1) % 5]);
	. . .
	/* think for awhile */
	. . .
}
```
However this does not prevent deadlocks, as all philosophers may pick up their left chopstick all at once

can fix by allowing only 4 philosiphers always having one more chopstick
pick up both chopsticks at the same time, fx introduce a new lock
odd ones pick their left
even ones pick their right

## Monitor Solution
Each philosopher can be in a state of THINKING HUNGRY or EATING and introduce 5 condition variables. Ultimately, this introduce a variation, where you must pick up both of the chopsticks at the same time. 

# Synchronization in windows
ensures processes will never be preempted while holding a spinlock.
provides mutex locks, semaphores, events and timers. Only specials are
* Events = condition variables
* Timers = signal thread that a specific amount of time has passed

Each thread are associated with a `dispatcher object` which may in a signaled or non-signaled state. If a thread blocks on a nonsignaled object it goes to the **waiting queue FOR THAT OBJECT**. When an object is signaled the kernel checks all threads which are waiting for this object, in the queue, and wakes up 1 or more threads.
![[Pasted image 20230602132821.png]]

# Synchronization in Linux
Prior to 2.6 linus kernel was nonpreemptive, aftwards preemptive

has support for atomic integers `atomic_t` 
![[Pasted image 20230602133740.png]]
* Mutex
	* `mutex_lock()` & `mutex_unlock()`, if not free the process is put to sleep.
	* spinlocks (short duration wait)
	* semaphores
disabling kernel preemption is also possible.
Linux processes information has a number of locks it is currently holding. If holding 0 locks, then the task can safely be preempted, if not then it should not be preempted.

# Posix Synchronization
Api for user mode - windows and linux mainly is in the kernel.

## Mutex Locks
```c
#include < pthread.h >

pthread mutex t mutex;

/* create and initialize the mutex lock */
pthread mutex init (&mutex,NULL)

/* acquire the mutex lock */
pthread mutex lock (&mutex);
/* critical section */
/* release the mutex lock */
pthread mutex unlock (&mutex);
```

## Semaphores
### Named
Multiple processes that are unrelated can use this to synchronize
```c
#include < semaphore.h >
sem t *sem;
/* Create the semaphore and initialize it to 1 */
sem = sem open ("SEM", O CREAT, 0666, 1);

/* acquire the semaphore */
sem wait (sem);
/* critical section */
/* release the semaphore */
sem post (sem);
```

### Unnamed
```c
#include < semaphore.h >
sem t sem;
//Create the semaphore and initialize it to 1
// 0 such that the sem is only allowed to be used by the threads created by this process. If not 0, this is placed in a region of shared memory
sem init (&sem, 0, 1);
```
same wait and post

## Condition variables
Are used in conjunction with mutex locks 
```c
pthread mutex lock(&mutex);
while (a != b)
	pthread cond wait (&cond var, &mutex);
pthread mutex unlock(&mutex);
```
the call to `pthread_cond_wait()` releases the lock such that others can update the shared data possibly updating them.

```c
pthread mutex lock(&mutex);
a = b;
pthread cond signal (&cond var);
pthread mutex unlock(&mutex);
```
Uses `pthread_cond_signal()` to signal the condition variable

# Synchronization in Java
## Java monitors
Every object has a lock  associated with it. Can use the `Synchronized` keyword on the object, if it is already owned the thread is put into the `entry-set` for the object, and if not it becomes the owner of the object.
When the object is signaled again one of the threads from the entry-set is then put as the owner of the lock.
If the thread cannot execute because of some condition missing, i can call to `wait()` with the object, and the lock is passed on to another thread in the entry-set putting the thread into the entry-set. Then the new thread can call `notify()` on the object to signal for some event that has happened.

## Reentrant Locks
```java
Lock key = new ReentrantLock();

key. lock ();
try {
/* critical section */
}
finally {
key. unlock ();
}
```
can call to `lock()` even if it has it, which will just give control back to the caller, which is why it is called `reentrant`.

## Semaphores
supports counting semaphores
```java
Semaphore sem = new Semaphore(1);
try {
	sem. acquire ();
/* critical section */
}
catch (InterruptedException ie) { }
finally {
	sem. release ();
}
```

## Condition variables
```java
Lock key = new ReentrantLock();
Condition condVar = key.newCondition();
```

# Alternative approaches to regular locking
Sometimes may be hard to manage the locking mechanisms, therefore some new methods may be used. Locking also introduces deadlocks from time to time, and has bad scaling.

## Transactional Memory
Can declare a block
```c
atomic{
	...
}
```
Then the construct of the block has to ensure that the block will be executed as if it is atomic. This can fx be implemented in hardware, using cache coherency protocol.

## OpenMP
the compiler directive and API for threads
can use `#pragma omp critical`
```c
void update(int value)
{
	# pragma omp critical
	{
		counter += value;
	}
}
```
Ensuring only one thread may be active in the block at one time.
Easier to use, as, again, the developer only has to spot the blocks that needs to be executed in an atomic fashion

## Functional Programing Languages
As functional programs does not allow for mutable objects, the state of the program is not subject to race conditions, and no concurrency measures has to be taken into account.

